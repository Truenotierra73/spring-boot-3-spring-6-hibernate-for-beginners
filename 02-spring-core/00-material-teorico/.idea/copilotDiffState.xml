<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/02-dependency-injection.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/02-dependency-injection.md" />
              <option name="originalContent" value="# Inyección de Dependencias en Spring&#10;&#10;La **Inyección de Dependencias (Dependency Injection, DI)** es un principio fundamental en el desarrollo de aplicaciones&#10;con Spring. Permite desacoplar los componentes de una aplicación, facilitando la reutilización, el mantenimiento y las&#10;pruebas.&#10;&#10;---&#10;&#10;## ¿Qué es la Inyección de Dependencias?&#10;&#10;La inyección de dependencias es un patrón de diseño que consiste en proporcionar a una clase sus dependencias desde el&#10;exterior, en lugar de que la propia clase las cree o gestione. Así, los objetos no son responsables de instanciar sus&#10;dependencias, sino que estas les son &quot;inyectadas&quot; por un contenedor externo (en este caso, el contenedor de Spring).&#10;&#10;---&#10;&#10;## ¿Cómo se realiza en Spring?&#10;&#10;Spring gestiona la inyección de dependencias a través de su contenedor de inversión de control (IoC). Existen varias&#10;formas de realizar la inyección de dependencias en Spring:&#10;&#10;### 1. Inyección por constructor (recomendada)&#10;&#10;- Las dependencias se pasan a través del constructor de la clase.&#10;- Permite definir las dependencias obligatorias de manera explícita.&#10;- Facilita la inmutabilidad y las pruebas unitarias.&#10;- Ejemplo:&#10;  ```java&#10;  @Service&#10;  public class MiServicio {&#10;      private final MiRepositorio repositorio;&#10;&#10;      // Inyección por constructor&#10;      public MiServicio(MiRepositorio repositorio) {&#10;          this.repositorio = repositorio;&#10;      }&#10;  }&#10;  ```&#10;&#10;### 2. Inyección por setter&#10;&#10;- Las dependencias se establecen mediante métodos setter.&#10;- Útil para dependencias opcionales.&#10;- Ejemplo:&#10;  ```java&#10;  @Service&#10;  public class MiServicio {&#10;      private MiRepositorio repositorio;&#10;&#10;      // Inyección por setter&#10;      @Autowired&#10;      public void setRepositorio(MiRepositorio repositorio) {&#10;          this.repositorio = repositorio;&#10;      }&#10;  }&#10;  ```&#10;&#10;### 3. Inyección por campo (no recomendada)&#10;&#10;- Las dependencias se inyectan directamente en los campos de la clase.&#10;- Dificulta las pruebas y el mantenimiento.&#10;- Ejemplo:&#10;  ```java&#10;  @Service&#10;  public class MiServicio {&#10;      // Inyección directa en el campo&#10;      @Autowired&#10;      private MiRepositorio repositorio;&#10;  }&#10;  ```&#10;&#10;---&#10;&#10;## Uso de la anotación `@Autowired`&#10;&#10;La anotación `@Autowired` es utilizada por Spring para indicar que una dependencia debe ser inyectada automáticamente&#10;por el contenedor. Puede aplicarse a constructores, métodos setter o directamente a campos.&#10;&#10;### ¿Qué hace @Autowired exactamente?&#10;&#10;`@Autowired` le dice a Spring: **&quot;Busca en tu contenedor un bean del tipo que necesito e inyéctamelo automáticamente&quot;**.&#10;&#10;**Proceso interno:**&#10;&#10;1. **Escaneo**: Spring encuentra la anotación `@Autowired`&#10;2. **Búsqueda**: Busca en su contenedor de beans uno que coincida por tipo&#10;3. **Resolución**: Si hay múltiples candidatos, usa estrategias de resolución (`@Primary`, `@Qualifier`)&#10;4. **Inyección**: Asigna automáticamente la instancia del bean&#10;5. **Gestión**: Spring gestiona el ciclo de vida de ambos objetos&#10;&#10;### ¿Es obligatoria?&#10;&#10;- **Constructor:** Desde Spring 4.3, si una clase tiene un único constructor, la anotación `@Autowired` no es&#10;  obligatoria en el constructor, ya que Spring lo detecta automáticamente.&#10;- **Setter y campo:** Es obligatoria para que Spring realice la inyección.&#10;- **Varios constructores:** Se debe indicar explícitamente cuál debe usar Spring con `@Autowired`.&#10;&#10;### ¿Qué función cumple?&#10;&#10;- Indica al contenedor de Spring que debe resolver e inyectar la dependencia correspondiente.&#10;- Permite la inyección automática de beans, facilitando el desacoplamiento y la configuración de la aplicación.&#10;- Elimina la necesidad de crear manualmente las instancias de las dependencias.&#10;&#10;### Ejemplos de uso&#10;&#10;- **En constructor (no obligatoria si es el único constructor):**&#10;  ```java&#10;  @Service&#10;  public class ClienteService {&#10;      private final ClienteRepository clienteRepository;&#10;&#10;      // Constructor único, @Autowired es opcional&#10;      public ClienteService(ClienteRepository clienteRepository) {&#10;          this.clienteRepository = clienteRepository;&#10;      }&#10;      &#10;      public Cliente buscarPorId(Long id) {&#10;          return clienteRepository.findById(id);&#10;      }&#10;  }&#10;  ```&#10;&#10;- **En setter (obligatoria):**&#10;  ```java&#10;  @Service&#10;  public class PedidoService {&#10;      private PedidoRepository pedidoRepository;&#10;&#10;      @Autowired&#10;      public void setPedidoRepository(PedidoRepository pedidoRepository) {&#10;          this.pedidoRepository = pedidoRepository;&#10;      }&#10;      &#10;      public Pedido crearPedido(Pedido pedido) {&#10;          return pedidoRepository.save(pedido);&#10;      }&#10;  }&#10;  ```&#10;&#10;- **En campo (obligatoria, pero no recomendada):**&#10;  ```java&#10;  @Service&#10;  public class FacturaService {&#10;      @Autowired&#10;      private FacturaRepository facturaRepository;&#10;      &#10;      public List&lt;Factura&gt; obtenerTodasLasFacturas() {&#10;          return facturaRepository.findAll();&#10;      }&#10;  }&#10;  ```&#10;&#10;- **Dependencias opcionales:**&#10;  Se puede indicar que una dependencia es opcional usando `@Autowired(required = false)`.&#10;  ```java&#10;  @Service&#10;  public class EmailService {&#10;      @Autowired(required = false)&#10;      private NotificacionService notificacionService;&#10;      &#10;      public void enviarEmail(String mensaje) {&#10;          // Verificar si el servicio está disponible&#10;          if (notificacionService != null) {&#10;              notificacionService.notificar(mensaje);&#10;          }&#10;          // Continuar con la lógica de envío de email&#10;      }&#10;  }&#10;  ```&#10;&#10;### Casos de uso comunes en Spring Boot&#10;&#10;1. **Inyección de Repository en Service:**&#10;   ```java&#10;   @Service&#10;   public class UsuarioService {&#10;       private final UsuarioRepository usuarioRepository;&#10;       &#10;       public UsuarioService(UsuarioRepository usuarioRepository) {&#10;           this.usuarioRepository = usuarioRepository;&#10;       }&#10;   }&#10;   ```&#10;&#10;2. **Inyección de Service en Controller:**&#10;   ```java&#10;   @RestController&#10;   @RequestMapping(&quot;/api/usuarios&quot;)&#10;   public class UsuarioController {&#10;       private final UsuarioService usuarioService;&#10;       &#10;       public UsuarioController(UsuarioService usuarioService) {&#10;           this.usuarioService = usuarioService;&#10;       }&#10;       &#10;       @GetMapping(&quot;/{id}&quot;)&#10;       public Usuario obtenerUsuario(@PathVariable Long id) {&#10;           return usuarioService.buscarPorId(id);&#10;       }&#10;   }&#10;   ```&#10;&#10;3. **Inyección de múltiples dependencias:**&#10;   ```java&#10;   @Service&#10;   public class ProcesadorPedido {&#10;       private final PedidoRepository pedidoRepository;&#10;       private final EmailService emailService;&#10;       private final InventarioService inventarioService;&#10;       &#10;       public ProcesadorPedido(PedidoRepository pedidoRepository,&#10;                             EmailService emailService,&#10;                             InventarioService inventarioService) {&#10;           this.pedidoRepository = pedidoRepository;&#10;           this.emailService = emailService;&#10;           this.inventarioService = inventarioService;&#10;       }&#10;       &#10;       public void procesarPedido(Pedido pedido) {&#10;           // Lógica de procesamiento usando todas las dependencias&#10;           inventarioService.verificarDisponibilidad(pedido);&#10;           pedidoRepository.save(pedido);&#10;           emailService.enviarConfirmacion(pedido);&#10;       }&#10;   }&#10;   ```&#10;&#10;### ¿Por qué usar @Autowired?&#10;&#10;**Ventajas:**&#10;&#10;- **Automatización**: Spring gestiona las dependencias automáticamente&#10;- **Desacoplamiento**: Las clases no necesitan saber cómo crear sus dependencias&#10;- **Flexibilidad**: Fácil cambio de implementaciones&#10;- **Testabilidad**: Fácil inyección de mocks en pruebas unitarias&#10;&#10;**Comparación - Sin Spring vs Con Spring:**&#10;&#10;```java&#10;// SIN SPRING - Acoplamiento fuerte&#10;public class PedidoService {&#10;&#9;private PedidoRepository repository = new PedidoRepositoryJpaImpl();&#10;&#9;private EmailService emailService = new EmailServiceImpl();&#10;&#9;// Difícil de testear y cambiar implementaciones&#10;}&#10;&#10;// CON SPRING - Bajo acoplamiento&#10;@Service&#10;public class PedidoService {&#10;&#9;private final PedidoRepository repository;&#10;&#9;private final EmailService emailService;&#10;&#10;&#9;// Spring inyecta las implementaciones correctas&#10;&#9;public PedidoService(PedidoRepository repository, EmailService emailService) {&#10;&#9;&#9;this.repository = repository;&#10;&#9;&#9;this.emailService = emailService;&#10;&#9;}&#10;}&#10;```&#10;&#10;---&#10;&#10;## Ventajas de la Inyección de Dependencias&#10;&#10;La inyección de dependencias ofrece múltiples beneficios que mejoran significativamente la calidad y mantenibilidad del código:&#10;&#10;### 1. **Bajo Acoplamiento**&#10;- Las clases no dependen de implementaciones concretas, sino de abstracciones (interfaces).&#10;- Facilita el cambio de implementaciones sin modificar el código cliente.&#10;- Ejemplo:&#10;  ```java&#10;  // Bajo acoplamiento - depende de la interfaz&#10;  @Service&#10;  public class PedidoService {&#10;      private final PedidoRepository repository; // Interfaz, no implementación concreta&#10;      &#10;      public PedidoService(PedidoRepository repository) {&#10;          this.repository = repository;&#10;      }&#10;  }&#10;  ```&#10;&#10;### 2. **Facilita las Pruebas Unitarias**&#10;- Permite inyectar mocks o stubs durante las pruebas.&#10;- No requiere modificar el código de producción para realizar pruebas.&#10;- Ejemplo:&#10;  ```java&#10;  @Test&#10;  void testProcesarPedido() {&#10;      // Crear mock del repositorio&#10;      PedidoRepository mockRepository = Mockito.mock(PedidoRepository.class);&#10;      &#10;      // Inyectar el mock en el servicio&#10;      PedidoService service = new PedidoService(mockRepository);&#10;      &#10;      // Realizar pruebas sin base de datos real&#10;  }&#10;  ```&#10;&#10;### 3. **Reutilización de Código**&#10;- Los componentes pueden ser reutilizados en diferentes contextos.&#10;- Facilita la creación de bibliotecas y módulos reutilizables.&#10;&#10;### 4. **Flexibilidad y Configuración**&#10;- Fácil intercambio de implementaciones según el entorno (desarrollo, pruebas, producción).&#10;- Configuración centralizada de dependencias.&#10;&#10;### 5. **Mantenimiento Simplificado**&#10;- Cambios en las dependencias no afectan a las clases que las usan.&#10;- Facilita la refactorización y evolución del código.&#10;&#10;### 6. **Principio de Responsabilidad Única**&#10;- Las clases se enfocan en su lógica de negocio, no en crear sus dependencias.&#10;- Mejora la cohesión y reduce la complejidad.&#10;&#10;---&#10;&#10;## ¿Qué es un Spring Bean?&#10;&#10;Un **Spring Bean** es cualquier objeto que es instanciado, configurado, ensamblado y gestionado por el contenedor IoC (Inversión de Control) de Spring. Los beans son los componentes fundamentales de una aplicación Spring.&#10;&#10;### Características de un Spring Bean:&#10;&#10;1. **Gestionado por Spring**: Su ciclo de vida es controlado completamente por el contenedor.&#10;2. **Singleton por defecto**: Una sola instancia por contexto de aplicación (configurable).&#10;3. **Inyectable**: Puede ser inyectado en otros beans mediante `@Autowired`.&#10;4. **Configurable**: Puede tener propiedades y configuraciones específicas.&#10;&#10;### ¿Cómo se define un Bean?&#10;&#10;#### 1. **Mediante anotaciones (más común):**&#10;```java&#10;@Service  // Define este objeto como un bean gestionado por Spring&#10;public class UsuarioService {&#10;    // Lógica del servicio&#10;}&#10;&#10;@Repository&#10;public class UsuarioRepository {&#10;    // Lógica de acceso a datos&#10;}&#10;&#10;@Controller&#10;public class UsuarioController {&#10;    // Lógica del controlador&#10;}&#10;```&#10;&#10;#### 2. **Mediante configuración Java:**&#10;```java&#10;@Configuration&#10;public class AppConfig {&#10;    &#10;    @Bean&#10;    public UsuarioService usuarioService() {&#10;        return new UsuarioService();&#10;    }&#10;    &#10;    @Bean&#10;    public DatabaseConnection databaseConnection() {&#10;        return new DatabaseConnection(&quot;jdbc:mysql://localhost:3306/mydb&quot;);&#10;    }&#10;}&#10;```&#10;&#10;#### 3. **Mediante configuración XML (menos usado):**&#10;```xml&#10;&lt;bean id=&quot;usuarioService&quot; class=&quot;com.ejemplo.UsuarioService&quot;/&gt;&#10;&lt;bean id=&quot;usuarioRepository&quot; class=&quot;com.ejemplo.UsuarioRepository&quot;/&gt;&#10;```&#10;&#10;### Ciclo de vida de un Bean:&#10;1. **Instanciación**: Spring crea la instancia del bean.&#10;2. **Inyección de propiedades**: Se inyectan las dependencias.&#10;3. **Inicialización**: Se ejecutan métodos de inicialización (`@PostConstruct`).&#10;4. **Uso**: El bean está disponible para ser usado.&#10;5. **Destrucción**: Se ejecutan métodos de limpieza (`@PreDestroy`) antes de ser destruido.&#10;&#10;### Ejemplo completo:&#10;```java&#10;@Service&#10;public class NotificacionService {&#10;    &#10;    @Autowired&#10;    private EmailService emailService; // Dependencia inyectada&#10;    &#10;    @PostConstruct  // Se ejecuta después de la creación e inyección&#10;    public void inicializar() {&#10;        System.out.println(&quot;NotificacionService inicializado&quot;);&#10;    }&#10;    &#10;    public void enviarNotificacion(String mensaje) {&#10;        emailService.enviar(mensaje);&#10;    }&#10;    &#10;    @PreDestroy  // Se ejecuta antes de la destrucción del bean&#10;    public void limpiar() {&#10;        System.out.println(&quot;Limpiando recursos del NotificacionService&quot;);&#10;    }&#10;}&#10;```&#10;&#10;---&#10;&#10;## Anotaciones Principales de Spring&#10;&#10;Spring proporciona un conjunto de anotaciones que facilitan la configuración y gestión de componentes. Aquí están las más importantes:&#10;&#10;### 1. **Anotaciones de Estereotipos (Stereotype Annotations)**&#10;&#10;#### `@Component`&#10;- **Qué hace**: Marca una clase como un componente de Spring, convirtiéndola en un bean.&#10;- **Para qué sirve**: Componente genérico, base para otras anotaciones más específicas.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Component&#10;  public class UtilityHelper {&#10;      public String formatearTexto(String texto) {&#10;          return texto.toUpperCase();&#10;      }&#10;  }&#10;  ```&#10;&#10;#### `@Service`&#10;- **Qué hace**: Especialización de `@Component` para la capa de servicio.&#10;- **Para qué sirve**: Indica que la clase contiene lógica de negocio.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Service&#10;  public class UsuarioService {&#10;      public Usuario crearUsuario(String nombre, String email) {&#10;          // Lógica de negocio para crear usuario&#10;          return new Usuario(nombre, email);&#10;      }&#10;  }&#10;  ```&#10;&#10;#### `@Repository`&#10;- **Qué hace**: Especialización de `@Component` para la capa de acceso a datos.&#10;- **Para qué sirve**: Indica que la clase maneja operaciones de base de datos.&#10;- **Ventaja adicional**: Automáticamente traduce excepciones de base de datos.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Repository&#10;  public class UsuarioRepository {&#10;      public Usuario findById(Long id) {&#10;          // Lógica para buscar usuario en la base de datos&#10;          return usuarioEncontrado;&#10;      }&#10;  }&#10;  ```&#10;&#10;#### `@Controller`&#10;- **Qué hace**: Especialización de `@Component` para la capa de presentación.&#10;- **Para qué sirve**: Maneja peticiones web y devuelve vistas (páginas web).&#10;- **Ejemplo**:&#10;  ```java&#10;  @Controller&#10;  public class UsuarioController {&#10;      @GetMapping(&quot;/usuarios&quot;)&#10;      public String listarUsuarios(Model model) {&#10;          // Lógica del controlador&#10;          return &quot;usuarios&quot;; // Nombre de la vista&#10;      }&#10;  }&#10;  ```&#10;&#10;#### `@RestController`&#10;- **Qué hace**: Combina `@Controller` + `@ResponseBody`.&#10;- **Para qué sirve**: Para APIs REST que devuelven datos en formato JSON/XML.&#10;- **Ejemplo**:&#10;  ```java&#10;  @RestController&#10;  @RequestMapping(&quot;/api/usuarios&quot;)&#10;  public class UsuarioRestController {&#10;      @GetMapping(&quot;/{id}&quot;)&#10;      public Usuario obtenerUsuario(@PathVariable Long id) {&#10;          // Devuelve directamente el objeto Usuario como JSON&#10;          return usuarioService.findById(id);&#10;      }&#10;  }&#10;  ```&#10;&#10;### 2. **Anotaciones de Inyección de Dependencias**&#10;&#10;#### `@Autowired`&#10;- **Qué hace**: Inyecta automáticamente dependencias por tipo.&#10;- **Para qué sirve**: Elimina la necesidad de crear manualmente las dependencias.&#10;- **Dónde se usa**: Constructores, métodos setter, campos.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Service&#10;  public class PedidoService {&#10;      @Autowired&#10;      private PedidoRepository repository;&#10;  }&#10;  ```&#10;&#10;#### `@Qualifier`&#10;- **Qué hace**: Especifica cuál bean inyectar cuando hay múltiples candidatos del mismo tipo.&#10;- **Para qué sirve**: Resolver ambigüedad en la inyección de dependencias.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Service&#10;  public class NotificacionService {&#10;      @Autowired&#10;      @Qualifier(&quot;emailService&quot;)  // Especifica cuál implementación usar&#10;      private MensajeService mensajeService;&#10;  }&#10;  ```&#10;&#10;#### `@Primary`&#10;- **Qué hace**: Marca un bean como la opción predeterminada cuando hay múltiples candidatos.&#10;- **Para qué sirve**: Establecer prioridad entre implementaciones.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Service&#10;  @Primary  // Esta implementación será la preferida por defecto&#10;  public class EmailServiceImpl implements MensajeService {&#10;      // Implementación principal&#10;  }&#10;  ```&#10;&#10;### 3. **Anotaciones de Configuración**&#10;&#10;#### `@Configuration`&#10;- **Qué hace**: Indica que la clase contiene configuración de beans.&#10;- **Para qué sirve**: Definir beans mediante métodos anotados con `@Bean`.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Configuration&#10;  public class DatabaseConfig {&#10;      @Bean&#10;      public DataSource dataSource() {&#10;          return new HikariDataSource();&#10;      }&#10;  }&#10;  ```&#10;&#10;#### `@Bean`&#10;- **Qué hace**: Define un bean dentro de una clase `@Configuration`.&#10;- **Para qué sirve**: Crear beans de clases de terceros o configuraciones complejas.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Configuration&#10;  public class AppConfig {&#10;      @Bean&#10;      public RestTemplate restTemplate() {&#10;          return new RestTemplate();  // Bean de una clase externa&#10;      }&#10;  }&#10;  ```&#10;&#10;#### `@ComponentScan`&#10;- **Qué hace**: Indica a Spring dónde buscar componentes para escanear.&#10;- **Para qué sirve**: Configurar el escaneo automático de componentes.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Configuration&#10;  @ComponentScan(basePackages = &quot;com.ejemplo.servicios&quot;)&#10;  public class AppConfig {&#10;      // Spring escaneará el paquete especificado buscando @Component, @Service, etc.&#10;  }&#10;  ```&#10;&#10;### 4. **Anotaciones del Ciclo de Vida**&#10;&#10;#### `@PostConstruct`&#10;- **Qué hace**: Ejecuta un método después de que el bean sea creado e inyectado.&#10;- **Para qué sirve**: Inicialización personalizada del bean.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Service&#10;  public class CacheService {&#10;      @PostConstruct&#10;      public void inicializarCache() {&#10;          // Código de inicialización&#10;          System.out.println(&quot;Cache inicializado&quot;);&#10;      }&#10;  }&#10;  ```&#10;&#10;#### `@PreDestroy`&#10;- **Qué hace**: Ejecuta un método antes de que el bean sea destruido.&#10;- **Para qué sirve**: Limpieza de recursos (cerrar conexiones, archivos, etc.).&#10;- **Ejemplo**:&#10;  ```java&#10;  @Service&#10;  public class DatabaseService {&#10;      @PreDestroy&#10;      public void cerrarConexiones() {&#10;          // Código de limpieza&#10;          System.out.println(&quot;Cerrando conexiones de base de datos&quot;);&#10;      }&#10;  }&#10;  ```&#10;&#10;### 5. **Anotaciones de Alcance (Scope)**&#10;&#10;#### `@Scope`&#10;- **Qué hace**: Define el alcance del bean (singleton, prototype, etc.).&#10;- **Para qué sirve**: Controlar cómo Spring gestiona las instancias del bean.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Service&#10;  @Scope(&quot;prototype&quot;)  // Nueva instancia cada vez que se solicite&#10;  public class TemporaryService {&#10;      // Cada inyección creará una nueva instancia&#10;  }&#10;  ```&#10;&#10;### 6. **Anotaciones de Inicialización Diferida**&#10;&#10;#### `@Lazy`&#10;- **Qué hace**: Retrasa la creación del bean hasta que sea realmente necesario.&#10;- **Para qué sirve**: Optimizar el tiempo de arranque de la aplicación.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Service&#10;  @Lazy  // No se creará hasta que alguien lo necesite&#10;  public class HeavyProcessingService {&#10;      // Bean que consume muchos recursos&#10;  }&#10;  ```&#10;&#10;### Resumen de Uso por Capas:&#10;&#10;```java&#10;// Capa de Controlador&#10;@RestController&#10;@RequestMapping(&quot;/api/productos&quot;)&#10;public class ProductoController {&#10;    @Autowired&#10;    private ProductoService productoService;&#10;}&#10;&#10;// Capa de Servicio  &#10;@Service&#10;public class ProductoService {&#10;    @Autowired&#10;    private ProductoRepository productoRepository;&#10;}&#10;&#10;// Capa de Repositorio&#10;@Repository&#10;public class ProductoRepository {&#10;    // Acceso a datos&#10;}&#10;&#10;// Configuración&#10;@Configuration&#10;public class AppConfig {&#10;    @Bean&#10;    public ModelMapper modelMapper() {&#10;        return new ModelMapper();&#10;    }&#10;}&#10;```&#10;&#10;---&#10;&#10;## Anotaciones principales en Spring&#10;&#10;- `@Component`, `@Service`, `@Repository`, `@Controller`: Indican que una clase es un componente gestionado por Spring.&#10;- `@Autowired`: Indica a Spring que debe inyectar la dependencia correspondiente.&#10;- `@Qualifier`: Permite especificar cuál implementación inyectar cuando hay varias disponibles.&#10;" />
              <option name="updatedContent" value="# Inyección de Dependencias en Spring&#10;&#10;La **Inyección de Dependencias (Dependency Injection, DI)** es un principio fundamental en el desarrollo de aplicaciones&#10;con Spring. Permite desacoplar los componentes de una aplicación, facilitando la reutilización, el mantenimiento y las&#10;pruebas.&#10;&#10;---&#10;&#10;## ¿Qué es la Inyección de Dependencias?&#10;&#10;La inyección de dependencias es un patrón de diseño que consiste en proporcionar a una clase sus dependencias desde el&#10;exterior, en lugar de que la propia clase las cree o gestione. Así, los objetos no son responsables de instanciar sus&#10;dependencias, sino que estas les son &quot;inyectadas&quot; por un contenedor externo (en este caso, el contenedor de Spring).&#10;&#10;---&#10;&#10;## ¿Cómo se realiza en Spring?&#10;&#10;Spring gestiona la inyección de dependencias a través de su contenedor de inversión de control (IoC). Existen varias&#10;formas de realizar la inyección de dependencias en Spring:&#10;&#10;### 1. Inyección por constructor (recomendada)&#10;&#10;- Las dependencias se pasan a través del constructor de la clase.&#10;- Permite definir las dependencias obligatorias de manera explícita.&#10;- Facilita la inmutabilidad y las pruebas unitarias.&#10;- Ejemplo:&#10;  ```java&#10;  @Service&#10;  public class MiServicio {&#10;      private final MiRepositorio repositorio;&#10;&#10;      // Inyección por constructor&#10;      public MiServicio(MiRepositorio repositorio) {&#10;          this.repositorio = repositorio;&#10;      }&#10;  }&#10;  ```&#10;&#10;### 2. Inyección por setter&#10;&#10;- Las dependencias se establecen mediante métodos setter.&#10;- Útil para dependencias opcionales.&#10;- Ejemplo:&#10;  ```java&#10;  @Service&#10;  public class MiServicio {&#10;      private MiRepositorio repositorio;&#10;&#10;      // Inyección por setter&#10;      @Autowired&#10;      public void setRepositorio(MiRepositorio repositorio) {&#10;          this.repositorio = repositorio;&#10;      }&#10;  }&#10;  ```&#10;&#10;### 3. Inyección por campo (no recomendada)&#10;&#10;- Las dependencias se inyectan directamente en los campos de la clase.&#10;- Dificulta las pruebas y el mantenimiento.&#10;- Ejemplo:&#10;  ```java&#10;  @Service&#10;  public class MiServicio {&#10;      // Inyección directa en el campo&#10;      @Autowired&#10;      private MiRepositorio repositorio;&#10;  }&#10;  ```&#10;&#10;---&#10;&#10;## Uso de la anotación `@Autowired`&#10;&#10;La anotación `@Autowired` es utilizada por Spring para indicar que una dependencia debe ser inyectada automáticamente&#10;por el contenedor. Puede aplicarse a constructores, métodos setter o directamente a campos.&#10;&#10;### ¿Qué hace @Autowired exactamente?&#10;&#10;`@Autowired` le dice a Spring: **&quot;Busca en tu contenedor un bean del tipo que necesito e inyéctamelo automáticamente&quot;**.&#10;&#10;**Proceso interno:**&#10;&#10;1. **Escaneo**: Spring encuentra la anotación `@Autowired`&#10;2. **Búsqueda**: Busca en su contenedor de beans uno que coincida por tipo&#10;3. **Resolución**: Si hay múltiples candidatos, usa estrategias de resolución (`@Primary`, `@Qualifier`)&#10;4. **Inyección**: Asigna automáticamente la instancia del bean&#10;5. **Gestión**: Spring gestiona el ciclo de vida de ambos objetos&#10;&#10;### ¿Es obligatoria?&#10;&#10;- **Constructor:** Desde Spring 4.3, si una clase tiene un único constructor, la anotación `@Autowired` no es&#10;  obligatoria en el constructor, ya que Spring lo detecta automáticamente.&#10;- **Setter y campo:** Es obligatoria para que Spring realice la inyección.&#10;- **Varios constructores:** Se debe indicar explícitamente cuál debe usar Spring con `@Autowired`.&#10;&#10;### ¿Qué función cumple?&#10;&#10;- Indica al contenedor de Spring que debe resolver e inyectar la dependencia correspondiente.&#10;- Permite la inyección automática de beans, facilitando el desacoplamiento y la configuración de la aplicación.&#10;- Elimina la necesidad de crear manualmente las instancias de las dependencias.&#10;&#10;### Ejemplos de uso&#10;&#10;- **En constructor (no obligatoria si es el único constructor):**&#10;  ```java&#10;  @Service&#10;  public class ClienteService {&#10;      private final ClienteRepository clienteRepository;&#10;&#10;      // Constructor único, @Autowired es opcional&#10;      public ClienteService(ClienteRepository clienteRepository) {&#10;          this.clienteRepository = clienteRepository;&#10;      }&#10;      &#10;      public Cliente buscarPorId(Long id) {&#10;          return clienteRepository.findById(id);&#10;      }&#10;  }&#10;  ```&#10;&#10;- **En setter (obligatoria):**&#10;  ```java&#10;  @Service&#10;  public class PedidoService {&#10;      private PedidoRepository pedidoRepository;&#10;&#10;      @Autowired&#10;      public void setPedidoRepository(PedidoRepository pedidoRepository) {&#10;          this.pedidoRepository = pedidoRepository;&#10;      }&#10;      &#10;      public Pedido crearPedido(Pedido pedido) {&#10;          return pedidoRepository.save(pedido);&#10;      }&#10;  }&#10;  ```&#10;&#10;- **En campo (obligatoria, pero no recomendada):**&#10;  ```java&#10;  @Service&#10;  public class FacturaService {&#10;      @Autowired&#10;      private FacturaRepository facturaRepository;&#10;      &#10;      public List&lt;Factura&gt; obtenerTodasLasFacturas() {&#10;          return facturaRepository.findAll();&#10;      }&#10;  }&#10;  ```&#10;&#10;- **Dependencias opcionales:**&#10;  Se puede indicar que una dependencia es opcional usando `@Autowired(required = false)`.&#10;  ```java&#10;  @Service&#10;  public class EmailService {&#10;      @Autowired(required = false)&#10;      private NotificacionService notificacionService;&#10;      &#10;      public void enviarEmail(String mensaje) {&#10;          // Verificar si el servicio está disponible&#10;          if (notificacionService != null) {&#10;              notificacionService.notificar(mensaje);&#10;          }&#10;          // Continuar con la lógica de envío de email&#10;      }&#10;  }&#10;  ```&#10;&#10;### Casos de uso comunes en Spring Boot&#10;&#10;1. **Inyección de Repository en Service:**&#10;   ```java&#10;   @Service&#10;   public class UsuarioService {&#10;       private final UsuarioRepository usuarioRepository;&#10;       &#10;       public UsuarioService(UsuarioRepository usuarioRepository) {&#10;           this.usuarioRepository = usuarioRepository;&#10;       }&#10;   }&#10;   ```&#10;&#10;2. **Inyección de Service en Controller:**&#10;   ```java&#10;   @RestController&#10;   @RequestMapping(&quot;/api/usuarios&quot;)&#10;   public class UsuarioController {&#10;       private final UsuarioService usuarioService;&#10;       &#10;       public UsuarioController(UsuarioService usuarioService) {&#10;           this.usuarioService = usuarioService;&#10;       }&#10;       &#10;       @GetMapping(&quot;/{id}&quot;)&#10;       public Usuario obtenerUsuario(@PathVariable Long id) {&#10;           return usuarioService.buscarPorId(id);&#10;       }&#10;   }&#10;   ```&#10;&#10;3. **Inyección de múltiples dependencias:**&#10;   ```java&#10;   @Service&#10;   public class ProcesadorPedido {&#10;       private final PedidoRepository pedidoRepository;&#10;       private final EmailService emailService;&#10;       private final InventarioService inventarioService;&#10;       &#10;       public ProcesadorPedido(PedidoRepository pedidoRepository,&#10;                             EmailService emailService,&#10;                             InventarioService inventarioService) {&#10;           this.pedidoRepository = pedidoRepository;&#10;           this.emailService = emailService;&#10;           this.inventarioService = inventarioService;&#10;       }&#10;       &#10;       public void procesarPedido(Pedido pedido) {&#10;           // Lógica de procesamiento usando todas las dependencias&#10;           inventarioService.verificarDisponibilidad(pedido);&#10;           pedidoRepository.save(pedido);&#10;           emailService.enviarConfirmacion(pedido);&#10;       }&#10;   }&#10;   ```&#10;&#10;### ¿Por qué usar @Autowired?&#10;&#10;**Ventajas:**&#10;&#10;- **Automatización**: Spring gestiona las dependencias automáticamente&#10;- **Desacoplamiento**: Las clases no necesitan saber cómo crear sus dependencias&#10;- **Flexibilidad**: Fácil cambio de implementaciones&#10;- **Testabilidad**: Fácil inyección de mocks en pruebas unitarias&#10;&#10;**Comparación - Sin Spring vs Con Spring:**&#10;&#10;```java&#10;// SIN SPRING - Acoplamiento fuerte&#10;public class PedidoService {&#10;&#9;private PedidoRepository repository = new PedidoRepositoryJpaImpl();&#10;&#9;private EmailService emailService = new EmailServiceImpl();&#10;&#9;// Difícil de testear y cambiar implementaciones&#10;}&#10;&#10;// CON SPRING - Bajo acoplamiento&#10;@Service&#10;public class PedidoService {&#10;&#9;private final PedidoRepository repository;&#10;&#9;private final EmailService emailService;&#10;&#10;&#9;// Spring inyecta las implementaciones correctas&#10;&#9;public PedidoService(PedidoRepository repository, EmailService emailService) {&#10;&#9;&#9;this.repository = repository;&#10;&#9;&#9;this.emailService = emailService;&#10;&#9;}&#10;}&#10;```&#10;&#10;---&#10;&#10;## Ventajas de la Inyección de Dependencias&#10;&#10;La inyección de dependencias ofrece múltiples beneficios que mejoran significativamente la calidad y mantenibilidad del código:&#10;&#10;### 1. **Bajo Acoplamiento**&#10;- Las clases no dependen de implementaciones concretas, sino de abstracciones (interfaces).&#10;- Facilita el cambio de implementaciones sin modificar el código cliente.&#10;- Ejemplo:&#10;  ```java&#10;  // Bajo acoplamiento - depende de la interfaz&#10;  @Service&#10;  public class PedidoService {&#10;      private final PedidoRepository repository; // Interfaz, no implementación concreta&#10;      &#10;      public PedidoService(PedidoRepository repository) {&#10;          this.repository = repository;&#10;      }&#10;  }&#10;  ```&#10;&#10;### 2. **Facilita las Pruebas Unitarias**&#10;- Permite inyectar mocks o stubs durante las pruebas.&#10;- No requiere modificar el código de producción para realizar pruebas.&#10;- Ejemplo:&#10;  ```java&#10;  @Test&#10;  void testProcesarPedido() {&#10;      // Crear mock del repositorio&#10;      PedidoRepository mockRepository = Mockito.mock(PedidoRepository.class);&#10;      &#10;      // Inyectar el mock en el servicio&#10;      PedidoService service = new PedidoService(mockRepository);&#10;      &#10;      // Realizar pruebas sin base de datos real&#10;  }&#10;  ```&#10;&#10;### 3. **Reutilización de Código**&#10;- Los componentes pueden ser reutilizados en diferentes contextos.&#10;- Facilita la creación de bibliotecas y módulos reutilizables.&#10;&#10;### 4. **Flexibilidad y Configuración**&#10;- Fácil intercambio de implementaciones según el entorno (desarrollo, pruebas, producción).&#10;- Configuración centralizada de dependencias.&#10;&#10;### 5. **Mantenimiento Simplificado**&#10;- Cambios en las dependencias no afectan a las clases que las usan.&#10;- Facilita la refactorización y evolución del código.&#10;&#10;### 6. **Principio de Responsabilidad Única**&#10;- Las clases se enfocan en su lógica de negocio, no en crear sus dependencias.&#10;- Mejora la cohesión y reduce la complejidad.&#10;&#10;---&#10;&#10;## ¿Qué es un Spring Bean?&#10;&#10;Un **Spring Bean** es cualquier objeto que es instanciado, configurado, ensamblado y gestionado por el contenedor IoC (Inversión de Control) de Spring. Los beans son los componentes fundamentales de una aplicación Spring.&#10;&#10;### Características de un Spring Bean:&#10;&#10;1. **Gestionado por Spring**: Su ciclo de vida es controlado completamente por el contenedor.&#10;2. **Singleton por defecto**: Una sola instancia por contexto de aplicación (configurable).&#10;3. **Inyectable**: Puede ser inyectado en otros beans mediante `@Autowired`.&#10;4. **Configurable**: Puede tener propiedades y configuraciones específicas.&#10;&#10;### ¿Cómo se define un Bean?&#10;&#10;#### 1. **Mediante anotaciones (más común):**&#10;```java&#10;@Service  // Define este objeto como un bean gestionado por Spring&#10;public class UsuarioService {&#10;    // Lógica del servicio&#10;}&#10;&#10;@Repository&#10;public class UsuarioRepository {&#10;    // Lógica de acceso a datos&#10;}&#10;&#10;@Controller&#10;public class UsuarioController {&#10;    // Lógica del controlador&#10;}&#10;```&#10;&#10;#### 2. **Mediante configuración Java:**&#10;```java&#10;@Configuration&#10;public class AppConfig {&#10;    &#10;    @Bean&#10;    public UsuarioService usuarioService() {&#10;        return new UsuarioService();&#10;    }&#10;    &#10;    @Bean&#10;    public DatabaseConnection databaseConnection() {&#10;        return new DatabaseConnection(&quot;jdbc:mysql://localhost:3306/mydb&quot;);&#10;    }&#10;}&#10;```&#10;&#10;#### 3. **Mediante configuración XML (menos usado):**&#10;```xml&#10;&lt;bean id=&quot;usuarioService&quot; class=&quot;com.ejemplo.UsuarioService&quot;/&gt;&#10;&lt;bean id=&quot;usuarioRepository&quot; class=&quot;com.ejemplo.UsuarioRepository&quot;/&gt;&#10;```&#10;&#10;### Ciclo de vida de un Bean:&#10;1. **Instanciación**: Spring crea la instancia del bean.&#10;2. **Inyección de propiedades**: Se inyectan las dependencias.&#10;3. **Inicialización**: Se ejecutan métodos de inicialización (`@PostConstruct`).&#10;4. **Uso**: El bean está disponible para ser usado.&#10;5. **Destrucción**: Se ejecutan métodos de limpieza (`@PreDestroy`) antes de ser destruido.&#10;&#10;### Ejemplo completo:&#10;```java&#10;@Service&#10;public class NotificacionService {&#10;    &#10;    @Autowired&#10;    private EmailService emailService; // Dependencia inyectada&#10;    &#10;    @PostConstruct  // Se ejecuta después de la creación e inyección&#10;    public void inicializar() {&#10;        System.out.println(&quot;NotificacionService inicializado&quot;);&#10;    }&#10;    &#10;    public void enviarNotificacion(String mensaje) {&#10;        emailService.enviar(mensaje);&#10;    }&#10;    &#10;    @PreDestroy  // Se ejecuta antes de la destrucción del bean&#10;    public void limpiar() {&#10;        System.out.println(&quot;Limpiando recursos del NotificacionService&quot;);&#10;    }&#10;}&#10;```&#10;&#10;---&#10;&#10;## Anotaciones Principales de Spring&#10;&#10;Spring proporciona un conjunto de anotaciones que facilitan la configuración y gestión de componentes. Aquí están las más importantes:&#10;&#10;### 1. **Anotaciones de Estereotipos (Stereotype Annotations)**&#10;&#10;#### `@Component`&#10;- **Qué hace**: Marca una clase como un componente de Spring, convirtiéndola en un bean.&#10;- **Para qué sirve**: Componente genérico, base para otras anotaciones más específicas.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Component&#10;  public class UtilityHelper {&#10;      public String formatearTexto(String texto) {&#10;          return texto.toUpperCase();&#10;      }&#10;  }&#10;  ```&#10;&#10;#### `@Service`&#10;- **Qué hace**: Especialización de `@Component` para la capa de servicio.&#10;- **Para qué sirve**: Indica que la clase contiene lógica de negocio.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Service&#10;  public class UsuarioService {&#10;      public Usuario crearUsuario(String nombre, String email) {&#10;          // Lógica de negocio para crear usuario&#10;          return new Usuario(nombre, email);&#10;      }&#10;  }&#10;  ```&#10;&#10;#### `@Repository`&#10;- **Qué hace**: Especialización de `@Component` para la capa de acceso a datos.&#10;- **Para qué sirve**: Indica que la clase maneja operaciones de base de datos.&#10;- **Ventaja adicional**: Automáticamente traduce excepciones de base de datos.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Repository&#10;  public class UsuarioRepository {&#10;      public Usuario findById(Long id) {&#10;          // Lógica para buscar usuario en la base de datos&#10;          return usuarioEncontrado;&#10;      }&#10;  }&#10;  ```&#10;&#10;#### `@Controller`&#10;- **Qué hace**: Especialización de `@Component` para la capa de presentación.&#10;- **Para qué sirve**: Maneja peticiones web y devuelve vistas (páginas web).&#10;- **Ejemplo**:&#10;  ```java&#10;  @Controller&#10;  public class UsuarioController {&#10;      @GetMapping(&quot;/usuarios&quot;)&#10;      public String listarUsuarios(Model model) {&#10;          // Lógica del controlador&#10;          return &quot;usuarios&quot;; // Nombre de la vista&#10;      }&#10;  }&#10;  ```&#10;&#10;#### `@RestController`&#10;- **Qué hace**: Combina `@Controller` + `@ResponseBody`.&#10;- **Para qué sirve**: Para APIs REST que devuelven datos en formato JSON/XML.&#10;- **Ejemplo**:&#10;  ```java&#10;  @RestController&#10;  @RequestMapping(&quot;/api/usuarios&quot;)&#10;  public class UsuarioRestController {&#10;      @GetMapping(&quot;/{id}&quot;)&#10;      public Usuario obtenerUsuario(@PathVariable Long id) {&#10;          // Devuelve directamente el objeto Usuario como JSON&#10;          return usuarioService.findById(id);&#10;      }&#10;  }&#10;  ```&#10;&#10;### 2. **Anotaciones de Inyección de Dependencias**&#10;&#10;#### `@Autowired`&#10;- **Qué hace**: Inyecta automáticamente dependencias por tipo.&#10;- **Para qué sirve**: Elimina la necesidad de crear manualmente las dependencias.&#10;- **Dónde se usa**: Constructores, métodos setter, campos.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Service&#10;  public class PedidoService {&#10;      @Autowired&#10;      private PedidoRepository repository;&#10;  }&#10;  ```&#10;&#10;#### `@Qualifier`&#10;- **Qué hace**: Especifica cuál bean inyectar cuando hay múltiples candidatos del mismo tipo.&#10;- **Para qué sirve**: Resolver ambigüedad en la inyección de dependencias.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Service&#10;  public class NotificacionService {&#10;      @Autowired&#10;      @Qualifier(&quot;emailService&quot;)  // Especifica cuál implementación usar&#10;      private MensajeService mensajeService;&#10;  }&#10;  ```&#10;&#10;#### `@Primary`&#10;- **Qué hace**: Marca un bean como la opción predeterminada cuando hay múltiples candidatos.&#10;- **Para qué sirve**: Establecer prioridad entre implementaciones.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Service&#10;  @Primary  // Esta implementación será la preferida por defecto&#10;  public class EmailServiceImpl implements MensajeService {&#10;      // Implementación principal&#10;  }&#10;  ```&#10;&#10;### 3. **Anotaciones de Configuración**&#10;&#10;#### `@Configuration`&#10;- **Qué hace**: Indica que la clase contiene configuración de beans.&#10;- **Para qué sirve**: Definir beans mediante métodos anotados con `@Bean`.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Configuration&#10;  public class DatabaseConfig {&#10;      @Bean&#10;      public DataSource dataSource() {&#10;          return new HikariDataSource();&#10;      }&#10;  }&#10;  ```&#10;&#10;#### `@Bean`&#10;- **Qué hace**: Define un bean dentro de una clase `@Configuration`.&#10;- **Para qué sirve**: Crear beans de clases de terceros o configuraciones complejas.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Configuration&#10;  public class AppConfig {&#10;      @Bean&#10;      public RestTemplate restTemplate() {&#10;          return new RestTemplate();  // Bean de una clase externa&#10;      }&#10;  }&#10;  ```&#10;&#10;#### `@ComponentScan`&#10;- **Qué hace**: Indica a Spring dónde buscar componentes para escanear.&#10;- **Para qué sirve**: Configurar el escaneo automático de componentes.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Configuration&#10;  @ComponentScan(basePackages = &quot;com.ejemplo.servicios&quot;)&#10;  public class AppConfig {&#10;      // Spring escaneará el paquete especificado buscando @Component, @Service, etc.&#10;  }&#10;  ```&#10;&#10;### 4. **Anotaciones del Ciclo de Vida**&#10;&#10;#### `@PostConstruct`&#10;- **Qué hace**: Ejecuta un método después de que el bean sea creado e inyectado.&#10;- **Para qué sirve**: Inicialización personalizada del bean.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Service&#10;  public class CacheService {&#10;      @PostConstruct&#10;      public void inicializarCache() {&#10;          // Código de inicialización&#10;          System.out.println(&quot;Cache inicializado&quot;);&#10;      }&#10;  }&#10;  ```&#10;&#10;#### `@PreDestroy`&#10;- **Qué hace**: Ejecuta un método antes de que el bean sea destruido.&#10;- **Para qué sirve**: Limpieza de recursos (cerrar conexiones, archivos, etc.).&#10;- **Ejemplo**:&#10;  ```java&#10;  @Service&#10;  public class DatabaseService {&#10;      @PreDestroy&#10;      public void cerrarConexiones() {&#10;          // Código de limpieza&#10;          System.out.println(&quot;Cerrando conexiones de base de datos&quot;);&#10;      }&#10;  }&#10;  ```&#10;&#10;### 5. **Anotaciones de Alcance (Scope)**&#10;&#10;#### `@Scope`&#10;- **Qué hace**: Define el alcance del bean (singleton, prototype, etc.).&#10;- **Para qué sirve**: Controlar cómo Spring gestiona las instancias del bean.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Service&#10;  @Scope(&quot;prototype&quot;)  // Nueva instancia cada vez que se solicite&#10;  public class TemporaryService {&#10;      // Cada inyección creará una nueva instancia&#10;  }&#10;  ```&#10;&#10;### 6. **Anotaciones de Inicialización Diferida**&#10;&#10;#### `@Lazy`&#10;- **Qué hace**: Retrasa la creación del bean hasta que sea realmente necesario.&#10;- **Para qué sirve**: Optimizar el tiempo de arranque de la aplicación.&#10;- **Ejemplo**:&#10;  ```java&#10;  @Service&#10;  @Lazy  // No se creará hasta que alguien lo necesite&#10;  public class HeavyProcessingService {&#10;      // Bean que consume muchos recursos&#10;  }&#10;  ```&#10;&#10;### Resumen de Uso por Capas:&#10;&#10;```java&#10;// Capa de Controlador&#10;@RestController&#10;@RequestMapping(&quot;/api/productos&quot;)&#10;public class ProductoController {&#10;    @Autowired&#10;    private ProductoService productoService;&#10;}&#10;&#10;// Capa de Servicio  &#10;@Service&#10;public class ProductoService {&#10;    @Autowired&#10;    private ProductoRepository productoRepository;&#10;}&#10;&#10;// Capa de Repositorio&#10;@Repository&#10;public class ProductoRepository {&#10;    // Acceso a datos&#10;}&#10;&#10;// Configuración&#10;@Configuration&#10;public class AppConfig {&#10;    @Bean&#10;    public ModelMapper modelMapper() {&#10;        return new ModelMapper();&#10;    }&#10;}&#10;```&#10;&#10;---&#10;&#10;## Anotaciones principales en Spring&#10;&#10;- `@Component`, `@Service`, `@Repository`, `@Controller`: Indican que una clase es un componente gestionado por Spring.&#10;- `@Autowired`: Indica a Spring que debe inyectar la dependencia correspondiente.&#10;- `@Qualifier`: Permite especificar cuál implementación inyectar cuando hay varias disponibles.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>